startsWith str, sequence {
	return #str >= #sequence and str[:#sequence] = sequence
}

endsWith str, sequence {
	return #str >= #sequence and str[-#sequence:] = sequence
}

strip &str {
	str ~= "^\\s*", "", "\\s*$", ""
}

function parsePamflett(char="#") {
	obj := [new map]
	set := { |key, val|
		if [ obj[-1] is list ] do
			index := parseInteger(key) if [ key =~ "[0-9]+" ] else push(#obj[-1])
			obj[-1] += "" while [ index >= #obj[-1] ]
			obj[-1][index] = val			
		else
			obj[-1][key] = val
		done
	}
	level := 1
	for line do
		continue if [ line =~ "\\s*" ]
		while [ not startsWith(line, char*level) and startsWith(line, char) ] do
			level --
			del obj[-1]
		done
		if startsWith(line, char*level) do
			stmt := line[level:]
			if startsWith(stmt, char) do
				error("syntax error on line `"..line.."': wrong level (should be "..level..")")
			done
			if (match("([^=]+)=(.*)", stmt))() | tryPull(l, key, val) do
				strip key
				strip val
				set key, val
				continue
			done
			if endsWith(stmt, "[]:") do
				key := stmt[:-3]
				strip key
				val := []
				until [ not tryPeek(x) or startsWith(peek(), char) ] do
					val += pull()
				done
				set key, val
				continue
			done
			if endsWith(stmt, ":") do
				key := stmt[:-1]
				strip key
				val := ""
				until startsWith(peek(), char) do
					val .= "\n" if [ #val > 0 ]
					val .= pull()
				done
				set key, val
				continue
			done
			if endsWith(stmt, "[]") do
				key := stmt[:-2]
				strip key
				val := new list
				set key, val
				obj += val
				level ++
				continue
			done
			if [ stmt =~ ".*[^\\wäöå]$" ] do
				new_char := stmt[-1:]
				key := stmt[:-1]
				strip key
				val := [while tryPeek(new_stmt) do
					break if startsWith(new_stmt, char)
					pull()
				done | parsePamflett(char=new_char)]
				set key, val
				continue
			done
			strip stmt
			val := new map
			set stmt, val
			obj += val
			level ++
		else
			error("syntax error on line `"..line.."': wrong level (should be "..level..")")
		done
	done
	return obj[0]
}

record PamflettValidator(node) {
	node : list = [node]
	
	function isMap {
		self.assert self.node[0] is map
	}
	
	function isList {
		self.assert self.node[0] is list
	}
	
	function isString {
		self.assert self.node[0] is string
	}
	
	function isStringOrMap validator {
		self.assert self.node[0] is string or self.node[0] is map
		validator() if [ self.node[0] is map ]
	}
	
	function contains key, validator {
		if [ self.node[0] is map ] do
			self.assert self.node[0][key]?
			validatePamflett self.node[0][key], validator
		done
	}
	
	function mayContain key, validator {
		if [ self.node[0] is map ] do
			self.assert self.node[0][key]?
			validatePamflett self.node[0][key], validator
		done
	}
	
	function forEach validator {
		if [ self.node[0] is list ] do
			validatePamflett elem, validator for elem in self.node[0]
		done
		if [ self.node[0] is map ] do
			validatePamflett self.node[0][key], validator for key in keys(self.node[0])
		done
	}
	
	function assert condition {
		push condition
	}
}

function validatePamflett(tree, validator) {
	validator(new PamflettValidator(tree))
}
